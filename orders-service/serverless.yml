service: orders-service

frameworkVersion: "3"

useDotenv: true

provider:
  name: aws
  runtime: nodejs18.x
  region: us-east-2
  stage: dev
  iam:
    role:
      statements:
        - ${file(./iam/CloudFrontIAM.yml):CloudFrontIAM}

  environment:
    REGION: us-east-2 # bucket is in us-east-2
    AUCTIONS_BUCKET_NAME: ${self:custom.AuctionsBucket.name}
    AUCTIONS_TABLE_NAME: ${self:custom.AuctionsTable.name}
    AUTHENTICATION_TABLE_NAME: ${self:custom.AuthenticationTable.name}

plugins:
  - serverless-plugin-typescript
  - serverless-iam-roles-per-function
  - serverless-step-functions
  - serverless-dotenv-plugin

functions:
  orderReceiptPDF:
    handler: src/handlers/orderReceiptPDF.handler
  # url:
  #   cors: true # I am not adding this because I am already making it URL from this resource "OrderReceiptDownloadPdfUrl"
  checkInventory:
    handler: src/handlers/checkInventory.handler
    iamRoleStatements:
      - ${file(./iam/AuctionTableIAM.yml):AuctionsTableGetAuctionsIAM}
  calculateTotal:
    handler: src/handlers/calculateTotal.handler
  redeemPoints:
    handler: src/handlers/redeemPoints.handler
    iamRoleStatements:
      - ${file(./iam/AuthenticationTableIAM.yml):AuthenticationTableUpdateItemIAM}
      - ${file(./iam/AuthenticationTableIAM.yml):AuthenticationTableGetItemIAM}
  billCustomer:
    handler: src/handlers/billCustomer.handler
  restoreRedeemPoints:
    handler: src/handlers/restoreRedeemPoints.handler
    iamRoleStatements:
      - ${file(./iam/AuthenticationTableIAM.yml):AuthenticationTableUpdateItemIAM}
  sqsWorker:
    handler: src/handlers/sqsWorker.handler
    iamRoleStatements:
      - ${file(./iam/AuctionTableIAM.yml):AuctionsTableUpdateAuctionsIAM}
    # triggered by sqs
    events:
      - sqs:
          arn: !GetAtt OrdersQueue.Arn
          # lambda will only pick one message from the queue if batchSize 1
          batchSize: 1
  restoreQuantity:
    handler: src/handlers/restoreQuantity.handler
    iamRoleStatements:
      - ${file(./iam/AuctionTableIAM.yml):AuctionsTableUpdateAuctionsIAM}

resources:
  Resources:
    # OrderReceiptDownloadPdfUrl: ${file(./resources/OrderReceiptDownloadPdfUrl.yml):OrderReceiptDownloadPdfUrl}
    # PermissionForURLInvoke: ${file(./resources/OrderReceiptDownloadPdfUrl.yml):PermissionForURLInvoke}
    # CloudFrontCachePolicy: ${file(./resources/CloudFront.yml):CloudFrontCachePolicy}
    # CloudFrontDistribution: ${file(./resources/CloudFront.yml):CloudFrontDistribution}
    OrdersQueue: ${file(./resources/OrdersQueue.yml):OrdersQueue)}

stepFunctions:
  stateMachines:
    storeCheckoutFlow:
      name: storeCheckoutFlow
      # definition means tell starting state
      definition:
        StartAt: checkInventory
        States:
          checkInventory:
            # first define type of state since its unit of task
            Type: Task
            Resource:
              # logical if arn of lambda function
              Fn::GetAtt: [checkInventory, Arn] # Or !GetAtt checkInventory.Arn
            # Catch the error we threw from lambda function
            Catch:
              - ErrorEquals: [AuctionNotFound]
                # next to another state if error found
                Next: auctionNotFoundError
              - ErrorEquals: [AuctionOutOfStock]
                # next to another state if this error found
                Next: auctionOutOfStockError
            ResultPath: "$.auction" # so input dont get replaced by return value, $ is entire input document and we are attching returned value of checkIndevntory as auction to it, if only $ to next function will replace the entire object with input of prev lambda function
            Next: calculateTotal
          calculateTotal:
            Type: Task
            Resource:
              Fn::GetAtt: [calculateTotal, Arn]
            ResultPath: "$.total"
            Next: isRedeemNeeded
          isRedeemNeeded:
            Type: Choice
            Choices:
              - Variable: $.redeem
                BooleanEquals: true
                Next: RedeemPoints
                # Default anything doesnot match this state, here it means customer doesnot want to redeem
            Default: BillCustomer
          RedeemPoints:
            Type: Task
            Resource:
              Fn::GetAtt: [redeemPoints, Arn]
            # so prev total will be replaced by new total which has points as well
            ResultPath: "$.total"
            Catch:
              # States.ALL means match with all errors general error handling because we have not given error names in lambda function as well
              - ErrorEquals: [States.ALL]
                Next: redeemPointsError
            Next: BillCustomer
          BillCustomer:
            Type: Task
            # must specify ResultPath otherwise function result will replace all input object
            ResultPath: "$.billingStatus"
            # retry the state
            Retry:
              - ErrorEquals: [States.ALL]
                MaxAttempts: 3
            # if it didnot work in the third time so catch the error
            Catch:
              - ErrorEquals: [States.ALL]
                # ResultPath so result doesnot replace entire input state
                # so to keep all other inputs intact
                ResultPath: "$.customerBilling"
                Next: billingError
            Resource:
              Fn::GetAtt: [billCustomer, Arn]
            Next: PrepareOrder
          PrepareOrder:
            # add it to sqs queue
            # then a lambda worker attach it to the sqs queue
            # and lambda worker will pick up a message
            # and a find a proper courier and attach the courier information
            # let say its info is courier email to dispatch an email to the courier
            # wait for out state machine until task is completed
            # so i will use callback pattern
            # attach task token to the message we are sending to sqs queue
            # and once lambda completed its task it will callback with task task token
            # then state machine when it will receive callback will move to next state
            Type: Task
            # Resource is particular to state and step function not arn
            # arn:aws:states:::sqs:sendMessage is resource related to state machine
            # suffix task token = waitForTaskToken
            # if u dont add waitForTaskToken its not going to wait make sure u add that
            Resource: arn:aws:states:::sqs:sendMessage.waitForTaskToken
            # ResulltPath because we are returning something from output object from sqsWorker
            ResulltPath: "$.courierStatus"
            Parameters:
              QueueUrl: !Ref OrdersQueue
              MessageBody:
                # $ represents entire message object in body of message
                Input.$: "$"
                # associate the task token
                # $$ indicates context object of state machine
                Token.$: "$$.Task.Token" # From the context
              # attach lamda worker that consumes the messages from sqs queue
            Catch:
              - ErrorEquals: [NoCourierAvailable]
                ResultPath: "$.courierError"
                Next: refundCustomer
            Next: DispatchOrder
          refundCustomer:
            Type: Pass
            Result: "Customer is refunded"
            ResultPath: "$.refundStatus"
            Next: restoreQuantity
          restoreQuantity:
            Type: Task
            Resource:
              Fn::GetAtt: [restoreQuantity, Arn]
            Next: restoreRedeemPoints
            Catch:
              - ErrorEquals: [States.ALL]
                ResultPath: "$.restoreQuantityError"
                Next: restoreQuantityError
          auctionNotFoundError:
            Type: Pass
            Result: "No such auction found"
            End: true
          auctionOutOfStockError:
            Type: Pass
            Result: "Sorry the book is out of stock"
            End: true
          redeemPointsError:
            Type: Pass
            Result: "Error in redeeming points"
            End: true
          billingError:
            Type: Pass
            Result: "Billing error"
            ResultPath: "$.billingStatus"
            Next: restoreRedeemPoints
          restoreRedeemPoints:
            Type: Task
            Resource:
              Fn::GetAtt: [restoreRedeemPoints, Arn]
            End: true
          restoreQuantityError:
            Type: Pass
            Result: "Quantity couldnot be restored"
            End: true

custom:
  AuctionsTable:
    # recheck all names properly from aws cloudformation as well
    arn: ${cf:auction-service-${sls:stage}.AuctionsTableArn}
    name: ${cf:auction-service-${sls:stage}.AuctionsTableName}
  AuthenticationTable:
    name: ${cf:authentication-service-${sls:stage}.AuthenticationTableName}
    arn: ${cf:authentication-service-${sls:stage}.AuthenticationTableArn}
  AuctionsBucket:
    name: auctions-bucket-sdsjj32kjds-${self:provider.stage}
  OrdersQueue:
    name: OrdersQueue-${sls:stage}
    arn: !GetAtt OrdersQueue.Arn
